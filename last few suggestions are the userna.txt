last few suggestions are the username input field should be a dominant focal point as this is the most vital field needed to be used to assign each bin number. At the moment it appears ordinary compared to all the other input boxes. Also, if simple to do we can add description windows to all remaining buttons for a complete user-friendly interface. for additional description buttons we should place them directly below each of their appropriate buttons to ensure we dont add to the over width of our ui window

import tkinter as tk
from tkinter import messagebox, ttk, filedialog
from PIL import Image, ImageTk
import os, sys, datetime, csv
import pdfplumber, fitz, subprocess, pytesseract, re
import asyncio, configparser
import warnings
import platform
import shutil
import threading
from flask import Flask, request, render_template, jsonify
from flask_socketio import SocketIO
import logging
import pyperclip

# Suppress urllib3 warnings
warnings.filterwarnings("ignore", category=UserWarning)

# Configure logging
logging.basicConfig(
    filename=os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", "swiftsale.log"),
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger()
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)
console_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
logger.addHandler(console_handler)

# Tesseract path setup
def setup_tesseract(config):
    if hasattr(sys, '_MEIPASS'):
        tesseract_path = os.path.join(sys._MEIPASS, 'tesseract', 'tesseract.exe')
    else:
        tesseract_path = config['Tesseract'].get('path', '')
        if not tesseract_path:
            if platform.system() == 'Windows':
                tesseract_path = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
            else:
                tesseract_path = shutil.which('tesseract') or '/usr/bin/tesseract'
    if not os.path.exists(tesseract_path) and not shutil.which(tesseract_path):
        raise RuntimeError(f"Tesseract not found at {tesseract_path}. Please install Tesseract-OCR.")
    pytesseract.pytesseract.tesseract_cmd = tesseract_path

# Load config
config = configparser.ConfigParser()
config_path = r"C:\Users\lovei\SCD_SALES\config.ini"
os.makedirs(os.path.dirname(config_path), exist_ok=True)
if not os.path.exists(config_path):
    config['Tesseract'] = {'path': r'C:\Program Files\Tesseract-OCR\tesseract.exe'}
    config['Subscription'] = {'tier': 'Gold', 'license_key': ''}
    config['GUI'] = {
        'top_buyer_text': 'Great job, {username}! Youâ€™ve snagged {count} items!',
        'giveaway_announcement_text': 'Giveaway #{number} Alert! Must be following us & share the stream to enter! Winner announced in a few minutes!',
        'flash_sale_announcement_text': 'ðŸš¨ Flash Sale Alert! Grab these deals before the timer runs out! ðŸš¨'
    }
    with open(config_path, 'w') as configfile:
        config.write(configfile)
if not config.read(config_path):
    logging.error(f"Failed to read config file at {config_path}")
    tk.Tk().withdraw()
    messagebox.showerror("Config Error", f"Failed to read config file at {config_path}. Please check the file.")
    sys.exit(1)

# Ensure all sections
for section in ['Tesseract', 'Subscription', 'GUI']:
    if section not in config:
        config[section] = {}
        if section == 'Tesseract':
            config[section]['path'] = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
        elif section == 'Subscription':
            config[section]['tier'] = 'Gold'
            config[section]['license_key'] = ''
        elif section == 'GUI':
            config[section]['top_buyer_text'] = 'Great job, {username}! Youâ€™ve snagged {count} items!'
            config[section]['giveaway_announcement_text'] = 'Giveaway #{number} Alert! Must be following us & share the stream to enter! Winner announced in a few minutes!'
            config[section]['flash_sale_announcement_text'] = 'ðŸš¨ Flash Sale Alert! Grab these deals before the timer runs out! ðŸš¨'
        with open(config_path, 'w') as configfile:
            config.write(configfile)

try:
    setup_tesseract(config)
except RuntimeError as e:
    logging.error(f"Tesseract setup failed: {str(e)}")
    tk.Tk().withdraw()
    messagebox.showerror("Tesseract Error", str(e))
    sys.exit(1)

class SCDWhatnotGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("SwiftSaleâ„¢")
        self.root.geometry("1000x600")
        self.root.configure(bg="#E6F0FA")

        self.loop = asyncio.new_event_loop()
        self.running = True
        self.schedule_asyncio()

        self.bidders = {}
        self.next_bin = 1
        self.next_giveaway_num = 1
        self.giveaway_count = 0
        self.label_data = []
        self.last_bidder = None
        self.show_id = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.show_start_time = datetime.datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")
        self.bidder_csv_path = os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", f"bidder_history_{self.show_id}.csv")
        os.makedirs(os.path.dirname(self.bidder_csv_path), exist_ok=True)

        self.tier_limits = {
            "Trial": {"bins": 25, "labels": 25},
            "Bronze": {"bins": 50, "labels": float('inf')},
            "Silver": {"bins": 150, "labels": float('inf')},
            "Gold": {"bins": 300, "labels": float('inf')}
        }
        self.valid_tiers = list(self.tier_limits.keys())

        self.config = configparser.ConfigParser()
        self.config_path = config_path
        if not self.config.read(self.config_path):
            logging.error(f"Failed to read config file at {self.config_path}")
            messagebox.showerror("Config Error", f"Failed to read config file at {self.config_path}. Please check the file.")
            sys.exit(1)

        self.tier = self.config['Subscription'].get('tier', 'Gold')
        self.top_buyer_text = self.config['GUI'].get('top_buyer_text', 'Great job, {username}! Youâ€™ve snagged {count} items!')
        self.giveaway_announcement_text = self.config['GUI'].get('giveaway_announcement_text', 'Giveaway #{number} Alert! Must be following us & share the stream to enter! Winner announced in a few minutes!')
        self.flash_sale_announcement_text = self.config['GUI'].get('flash_sale_announcement_text', 'ðŸš¨ Flash Sale Alert! Grab these deals before the timer runs out! ðŸš¨')
        self.max_bins = self.tier_limits[self.tier]['bins']
        self.max_labels = self.tier_limits[self.tier]['labels']
        self.license_key = self.config['Subscription'].get('license_key', '')

        self.flask_app = Flask(__name__)
        self.socketio = SocketIO(self.flask_app, async_mode='eventlet')
        self.latest_bin_assignment = "Waiting for bidder..."

        @self.flask_app.route('/')
        def index():
            return render_template('index.html')

        @self.flask_app.route('/get_latest')
        def get_latest():
            return jsonify({'data': self.latest_bin_assignment})

        @self.socketio.on('connect')
        def handle_connect():
            self.socketio.emit('update', {'data': self.latest_bin_assignment})

        def run_flask():
            port = int(os.environ.get('PORT', 5000))
            self.socketio.run(self.flask_app, host='0.0.0.0', port=port)
            logging.info(f"Flask server started on port {port}")

        flask_thread = threading.Thread(target=run_flask, daemon=True)
        flask_thread.start()

        self.field_info = {
            "search": "Search for bidder by username or partial matches for transactions.",
            "username": "Enter Whatnot username to assign bin number.",
            "quantity": "Number of items won (default: 1).",
            "weight_class": "Select weight class or 'PU Only' (optional).",
            "giveaway": "Mark as giveaway to assign unique number.",
            "label_text": "Custom label text (e.g., 'Bin: {bin_number}').",
            "text_x": "X-coordinate for label text (pixels).",
            "text_y": "Y-coordinate for label text (pixels).",
            "bin_range": "Bin range for printing labels (e.g., '1-25').",
            "avg_sell_rate": "Calculate average time between item sales.",
            "settings": "Opens the Settings window to customize subscription tier, top buyer text, giveaway announcement text, and flash sale announcement text.",
            "start_giveaway": "Copies a giveaway announcement to the clipboard for pasting into Whatnot chat. Includes an auto-incrementing giveaway number. Text is customizable in Settings.",
            "start_flash_sale": "Copies a flash sale announcement to the clipboard for pasting into Whatnot chat to promote time-limited deals. Text is customizable in Settings.",
            "top_buyers": "Shows the top 3 buyers with the most items won. Click a buyerâ€™s name to copy a shoutout message for Whatnot chat."
        }

        # Main container with two columns
        self.main_container = tk.Frame(root, bg="#E6F0FA")
        self.main_container.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.main_container.grid_columnconfigure(0, weight=3)
        self.main_container.grid_columnconfigure(1, weight=1)
        self.main_container.grid_rowconfigure(0, weight=1)

        # Header Frame
        header = tk.Frame(root, bg="#1A2526")
        header.grid(row=0, column=0, columnspan=2, sticky="ew", padx=2, pady=2)
        logo_path = os.path.join(os.path.dirname(__file__), "SwiftSale.png")
        try:
            logo_img = Image.open(logo_path).resize((75, 60), Image.LANCZOS)
            self.logo = ImageTk.PhotoImage(logo_img)
            tk.Label(header, image=self.logo, bg="#1A2526").pack(side="left", padx=5)
            tk.Label(header, text="SwiftSaleâ„¢", font=("Helvetica", 12, "bold"), fg="#FFFFFF", bg="#1A2526").pack(side="left")
        except Exception as e:
            logging.warning(f"Failed to load logo: {str(e)}")
            tk.Label(header, text="SwiftSaleâ„¢", font=("Helvetica", 12, "bold"), fg="#FFFFFF", bg="#1A2526").pack(side="left", padx=5)
        tk.Label(header, text=f"Show ID: {self.show_id} | Tier: {self.tier} (Bins: {self.max_bins}, Labels: {'Unlimited' if self.max_labels == float('inf') else self.max_labels})", font=("Helvetica", 8), fg="#FFFFFF", bg="#1A2526", name="header_label").pack(side="right", padx=5)

        # Left Main Frame
        main = tk.Frame(self.main_container, bg="#E6F0FA")
        main.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        main.grid_columnconfigure(0, weight=1)
        main.grid_rowconfigure(4, weight=1)

        # Input Frame
        input_frame = tk.Frame(main, bg="#E6F0FA")
        input_frame.pack(fill="x", padx=5, pady=2)

        # Announcement Display and Current Bidder
        self.announcement_text = tk.Text(input_frame, height=2, width=50, font=("Helvetica", 8), bg="#FFFFFF", state="disabled")
        self.announcement_text.grid(row=0, column=0, columnspan=5, padx=2, pady=2)
        self.current_bidder_label = tk.Label(input_frame, text="", font=("Helvetica", 10, "bold"), bg="#E6F0FA")
        self.current_bidder_label.grid(row=0, column=5, padx=5, sticky="w")

        # Search and Settings
        tk.Label(input_frame, text="Search:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=1, column=0, padx=2, sticky="e")
        self.search_entry = tk.Entry(input_frame, width=15, font=("Helvetica", 8))
        self.search_entry.grid(row=1, column=1, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("search"), width=2, font=("Helvetica", 8)).grid(row=1, column=2)
        tk.Button(input_frame, text="Search", command=self.search_bidders, bg="#E63946", fg="#FFFFFF", font=("Helvetica", 8)).grid(row=1, column=3, padx=2)
        tk.Button(input_frame, text="Settings", command=self.open_settings, bg="#FFA500", fg="#FFFFFF", font=("Helvetica", 8)).grid(row=1, column=4, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("settings"), width=2, font=("Helvetica", 8)).grid(row=1, column=5)

        # Transaction Inputs
        tk.Label(input_frame, text="Username:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=2, column=0, padx=2, sticky="e")
        self.username_entry = tk.Entry(input_frame, width=15, font=("Helvetica", 8))
        self.username_entry.grid(row=2, column=1, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("username"), width=2, font=("Helvetica", 8)).grid(row=2, column=2)

        tk.Label(input_frame, text="Quantity:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=3, column=0, padx=2, sticky="e")
        self.qty_entry = tk.Entry(input_frame, width=15, font=("Helvetica", 8))
        self.qty_entry.insert(0, "1")
        self.qty_entry.grid(row=3, column=1, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("quantity"), width=2, font=("Helvetica", 8)).grid(row=3, column=2)

        tk.Label(input_frame, text="Weight:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=3, column=3, padx=2, sticky="e")
        self.weight_entry = ttk.Combobox(input_frame, values=["A", "B", "C", "D", "E", "F", "G", "H", "PU Only"], width=10, state="readonly", font=("Helvetica", 8))
        self.weight_entry.grid(row=3, column=4, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("weight_class"), width=2, font=("Helvetica", 8)).grid(row=3, column=5)
        tk.Button(input_frame, text="Avg Sell Rate", command=self.show_avg_sell_rate, bg="#4682B4", fg="#FFFFFF", font=("Helvetica", 8)).grid(row=3, column=6, padx=2)
        tk.Button(input_frame, text="Start Giveaway", command=self.copy_giveaway_announcement, bg="#FFD700", fg="#FFFFFF", font=("Helvetica", 8)).grid(row=3, column=7, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("start_giveaway"), width=2, font=("Helvetica", 8)).grid(row=3, column=8)
        tk.Button(input_frame, text="Start Flash Sale", command=self.copy_flash_sale_announcement, bg="#FF4500", fg="#FFFFFF", font=("Helvetica", 8)).grid(row=3, column=9, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("start_flash_sale"), width=2, font=("Helvetica", 8)).grid(row=3, column=10)

        self.giveaway_var = tk.BooleanVar()
        tk.Checkbutton(input_frame, text="Giveaway", variable=self.giveaway_var, bg="#E6F0FA", font=("Helvetica", 8)).grid(row=4, column=1, padx=2, sticky="w")
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("giveaway"), width=2, font=("Helvetica", 8)).grid(row=4, column=2)

        tk.Label(input_frame, text="Label Text:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=5, column=0, padx=2, sticky="e")
        self.label_text_entry = tk.Entry(input_frame, width=15, font=("Helvetica", 8))
        self.label_text_entry.insert(0, "Bin: {bin_number}")
        self.label_text_entry.grid(row=5, column=1, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("label_text"), width=2, font=("Helvetica", 8)).grid(row=5, column=2)

        tk.Label(input_frame, text="Text X:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=5, column=3, padx=2, sticky="e")
        self.text_x_entry = tk.Entry(input_frame, width=10, font=("Helvetica", 8))
        self.text_x_entry.insert(0, "50")
        self.text_x_entry.grid(row=5, column=4, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("text_x"), width=2, font=("Helvetica", 8)).grid(row=5, column=5)

        tk.Label(input_frame, text="Text Y:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=6, column=3, padx=2, sticky="e")
        self.text_y_entry = tk.Entry(input_frame, width=10, font=("Helvetica", 8))
        self.text_y_entry.insert(0, "50")
        self.text_y_entry.grid(row=6, column=4, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("text_y"), width=2, font=("Helvetica", 8)).grid(row=6, column=5)

        tk.Label(input_frame, text="Bin Range:", bg="#E6F0FA", font=("Helvetica", 8)).grid(row=6, column=0, padx=2, sticky="e")
        self.bin_range_entry = tk.Entry(input_frame, width=15, font=("Helvetica", 8))
        self.bin_range_entry.insert(0, f"1-{self.max_bins}")
        self.bin_range_entry.grid(row=6, column=1, padx=2)
        tk.Button(input_frame, text="?", command=lambda: self.show_field_info("bin_range"), width=2, font=("Helvetica", 8)).grid(row=6, column=2)

        # Button Frame
        btn_frame = tk.Frame(main, bg="#E6F0FA")
        btn_frame.pack(fill="x", padx=5, pady=2)
        buttons = [
            ("Add Bidder", self.add_bidder, "#2ECC71"),
            ("Print Bidders", self.print_bidders, "#E63946"),
            ("Import Labels", self.import_labels, "#3498DB"),
            ("Print Labels", self.print_labels, "#9B59B6"),
            ("Test Print", self.test_print_label, "#FF5733"),
            ("Preview Labels", self.preview_labels, "#00CED1"),
            ("Export Labels", self.export_labels, "#228B22"),
            ("Clear Data", self.clear_data, "#A8D5E2"),
            ("Printer Guide", self.show_printer_setup, "#F1C40F")
        ]
        for i, (text, cmd, bg) in enumerate(buttons):
            tk.Button(btn_frame, text=text, command=cmd, bg=bg, fg="#FFFFFF", width=12, font=("Helvetica", 8)).grid(row=0, column=i, padx=2)

        # Search Result
        self.search_result = tk.Label(main, text="", wraplength=500, bg="#E6F0FA", font=("Helvetica", 8))
        self.search_result.pack(pady=2)

        # Treeview
        self.tree = ttk.Treeview(main, columns=("Username", "Bin", "Qty", "Weight", "Giveaway", "GiveawayNum", "Timestamp"), show="tree headings", height=8)
        style = ttk.Style()
        style.configure("Treeview", font=("Helvetica", 8), rowheight=18)
        style.configure("Treeview.Heading", font=("Helvetica", 8, "bold"))
        self.tree.heading("#0", text="")
        self.tree.column("#0", width=20)
        for col in ("Username", "Bin", "Qty", "Weight", "Giveaway", "GiveawayNum", "Timestamp"):
            self.tree.heading(col, text=col)
            self.tree.column(col, width=80 if col != "Timestamp" else 120)
        self.tree.pack(fill="both", expand=True, padx=5, pady=2)
        scrollbar = ttk.Scrollbar(main, orient="vertical", command=self.tree.yview)
        scrollbar.pack(side="right", fill="y")
        self.tree.configure(yscrollcommand=scrollbar.set)

        # Bin Display
        tk.Label(main, text="Assigned Bins:", font=("Helvetica", 10, "bold"), bg="#E6F0FA").pack(anchor="w", padx=5)
        self.bin_display = tk.Text(main, height=4, width=60, font=("Helvetica", 10), bg="#FFFFFF")
        self.bin_display.pack(fill="x", padx=5, pady=2)
        self.bin_display.config(state="disabled")

        # Top Buyers Frame
        top_buyers_frame = tk.Frame(self.main_container, bg="#E6F0FA", bd=2, relief="groove")
        top_buyers_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        top_buyers_header = tk.Frame(top_buyers_frame, bg="#E6F0FA")
        top_buyers_header.pack(fill="x")
        tk.Label(top_buyers_header, text="Top Buyers", font=("Helvetica", 10, "bold"), bg="#E6F0FA").pack(side="left", padx=5, pady=2)
        tk.Button(top_buyers_header, text="?", command=lambda: self.show_field_info("top_buyers"), width=2, font=("Helvetica", 8)).pack(side="right", padx=5)
        self.top_buyers_labels = []
        for i in range(3):
            label = tk.Label(top_buyers_frame, text="", font=("Helvetica", 8), bg="#E6F0FA", wraplength=200, cursor="hand2")
            label.pack(anchor="w", padx=5, pady=1)
            label.bind("<Button-1>", lambda e, idx=i: self.copy_top_buyer_text(idx))
            self.top_buyers_labels.append(label)
        self.update_top_buyers()

        # Footer
        footer = tk.Frame(root, bg="#1A2526")
        footer.grid(row=2, column=0, columnspan=2, sticky="ew", padx=2, pady=2)
        tk.Label(footer, text=f"License ID: SS-2025-001 | SwiftSaleâ„¢ Â© 2025 | Bins: {len(self.bidders)}/{self.max_bins} | Labels: {len(self.label_data)}/{'Unlimited' if self.max_labels == float('inf') else self.max_labels}", font=("Helvetica", 8), fg="#FFFFFF", bg="#1A2526", name="footer_label").pack(side="left", padx=5)
        stats_frame = tk.Frame(footer, bg="#1A2526")
        stats_frame.pack(side="right", padx=5)
        self.stats_text = tk.Text(stats_frame, height=1, width=40, font=("Helvetica", 8), bg="#FFFFFF", cursor="hand2")
        self.stats_text.pack()
        self.stats_text.insert(tk.END, "No stats yet")
        self.stats_text.config(state="disabled")
        self.stats_text.bind("<Button-1>", lambda e: self.copy_stats_text())
        self.update_stats()

        self.update_footer()
        root.grid_columnconfigure(0, weight=1)
        root.grid_rowconfigure(1, weight=1)
        root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def copy_top_buyer_text(self, index):
        if index < len(self.top_buyers):
            username, count = self.top_buyers[index]
            text = self.top_buyer_text.format(username=username, count=count)
            pyperclip.copy(text)
            messagebox.showinfo("Copied", f"Copied: {text}")
            logging.info(f"Copied top buyer text: {text}")

    def update_top_buyers(self):
        self.top_buyers = sorted(
            [(data['original_username'], data['total_items']) for username, data in self.bidders.items()],
            key=lambda x: x[1], reverse=True
        )[:3]
        for i, label in enumerate(self.top_buyers_labels):
            if i < len(self.top_buyers):
                username, count = self.top_buyers[i]
                text = self.top_buyer_text.format(username=username, count=count)
                label.config(text=f"{username}: {count} items\n{text}")
            else:
                label.config(text="")
        logging.info("Updated top buyers display")

    def copy_stats_text(self):
        text = self.stats_text.get("1.0", tk.END).strip()
        pyperclip.copy(text)
        messagebox.showinfo("Copied", f"Copied: {text}")
        logging.info(f"Copied stats text: {text}")

    def update_stats(self):
        total_items = sum(data['total_items'] for data in self.bidders.values())
        unique_buyers = len(self.bidders)
        avg_items = round(total_items / unique_buyers, 1) if unique_buyers > 0 else 0
        stats_text = f"Sold {total_items} items to {unique_buyers} buyers, avg {avg_items} items each"
        self.stats_text.config(state="normal")
        self.stats_text.delete("1.0", tk.END)
        self.stats_text.insert(tk.END, stats_text)
        self.stats_text.config(state="disabled")
        logging.info("Updated stats display")

    def copy_giveaway_announcement(self):
        text = self.giveaway_announcement_text.format(number=self.giveaway_count + 1)
        pyperclip.copy(text)
        self.announcement_text.config(state="normal")
        self.announcement_text.delete("1.0", tk.END)
        self.announcement_text.insert(tk.END, text)
        self.announcement_text.config(state="disabled")
        messagebox.showinfo("Copied", f"Copied: {text}")
        logging.info(f"Copied giveaway announcement: {text}")

    def copy_flash_sale_announcement(self):
        text = self.flash_sale_announcement_text
        pyperclip.copy(text)
        self.announcement_text.config(state="normal")
        self.announcement_text.delete("1.0", tk.END)
        self.announcement_text.insert(tk.END, text)
        self.announcement_text.config(state="disabled")
        messagebox.showinfo("Copied", f"Copied: {text}")
        logging.info(f"Copied flash sale announcement: {text}")

    def on_closing(self):
        self.running = False
        self.loop.call_soon_threadsafe(self.loop.stop)
        try:
            self.loop.run_until_complete(self.loop.shutdown_asyncgens())
        finally:
            self.loop.close()
        self.root.destroy()
        logging.info("Application closed")

    def schedule_asyncio(self):
        if not self.running:
            return
        try:
            self.loop.run_until_complete(asyncio.sleep(0))
        except RuntimeError:
            pass
        self.root.after(10, self.schedule_asyncio)

    async def run_coroutine(self, coro):
        try:
            return await coro
        except Exception as e:
            logging.error(f"Async operation failed: {str(e)}")
            self.root.after(0, lambda: messagebox.showerror("Async Error", f"Async operation failed: {str(e)}"))

    def validate_license_key(self, key, tier):
        return True if tier == 'Gold' else False

    def show_field_info(self, field):
        messagebox.showinfo(f"{field.replace('_', ' ').title()} Info", self.field_info[field])
        logging.info(f"Displayed info for {field}")

    def update_footer(self):
        footer_text = f"License ID: SS-2025-001 | SwiftSaleâ„¢ Â© 2025 | Bins: {len(self.bidders)}/{self.max_bins} | Labels: {len(self.label_data)}/{'Unlimited' if self.max_labels == float('inf') else self.max_labels}"
        try:
            footer_label = self.root.nametowidget(".!frame3.footer_label")
            footer_label.config(text=footer_text)
        except KeyError:
            logging.warning("Footer label not found")
        self.update_stats()
        self.root.update()

    def open_settings(self):
        win = tk.Toplevel(self.root)
        win.title("Settings")
        win.geometry("400x300")
        win.configure(bg="#E6F0FA")

        tk.Label(win, text="Subscription Tier:", bg="#E6F0FA", font=("Helvetica", 8)).pack(pady=5)
        tier_entry = tk.Entry(win, width=40, font=("Helvetica", 8))
        tier_entry.insert(0, self.tier or 'Gold')
        tier_entry.pack(pady=5)

        tk.Label(win, text="Top Buyer Text:", bg="#E6F0FA", font=("Helvetica", 8)).pack(pady=5)
        top_buyer_entry = tk.Entry(win, width=40, font=("Helvetica", 8))
        top_buyer_entry.insert(0, self.top_buyer_text)
        top_buyer_entry.pack(pady=5)
        tk.Label(win, text="Use {username} and {count} for placeholders", bg="#E6F0FA", font=("Helvetica", 8), fg="#555").pack()

        tk.Label(win, text="Giveaway Announcement Text:", bg="#E6F0FA", font=("Helvetica", 8)).pack(pady=5)
        giveaway_entry = tk.Entry(win, width=40, font=("Helvetica", 8))
        giveaway_entry.insert(0, self.giveaway_announcement_text)
        giveaway_entry.pack(pady=5)
        tk.Label(win, text="Use {number} for giveaway number", bg="#E6F0FA", font=("Helvetica", 8), fg="#555").pack()

        tk.Label(win, text="Flash Sale Announcement Text:", bg="#E6F0FA", font=("Helvetica", 8)).pack(pady=5)
        flash_sale_entry = tk.Entry(win, width=40, font=("Helvetica", 8))
        flash_sale_entry.insert(0, self.flash_sale_announcement_text)
        flash_sale_entry.pack(pady=5)

        def save():
            self.tier = tier_entry.get().strip()
            self.top_buyer_text = top_buyer_entry.get().strip()
            self.giveaway_announcement_text = giveaway_entry.get().strip()
            self.flash_sale_announcement_text = flash_sale_entry.get().strip()

            if self.tier not in self.valid_tiers:
                messagebox.showerror("Error", f"Invalid tier! Choose from: {', '.join(self.valid_tiers)}")
                logging.warning(f"Invalid tier entered: {self.tier}")
                return

            self.config['Subscription']['tier'] = self.tier
            self.config['GUI']['top_buyer_text'] = self.top_buyer_text
            self.config['GUI']['giveaway_announcement_text'] = self.giveaway_announcement_text
            self.config['GUI']['flash_sale_announcement_text'] = self.flash_sale_announcement_text

            try:
                with open(self.config_path, 'w') as f:
                    self.config.write(f)
                self.max_bins = self.tier_limits[self.tier]['bins']
                self.max_labels = self.tier_limits[self.tier]['labels']
                messagebox.showinfo("Success", "Settings saved!")
                win.destroy()
                self.root.nametowidget(".!frame.header_label").config(
                    text=f"Show ID: {self.show_id} | Tier: {self.tier} (Bins: {self.max_bins}, Labels: {'Unlimited' if self.max_labels == float('inf') else self.max_labels})"
                )
                self.update_footer()
                self.update_top_buyers()
                logging.info("Settings saved")
            except Exception as e:
                logging.error(f"Settings save failed: {str(e)}")
                messagebox.showerror("Error", f"Save failed: {str(e)}")

        tk.Button(win, text="Save Settings", command=save, bg="#2ECC71", fg="#FFFFFF", font=("Helvetica", 8)).pack(pady=5)

    def update_bin_display(self):
        self.bin_display.config(state="normal")
        self.bin_display.delete(1.0, tk.END)
        if not self.bidders:
            self.bin_display.insert(tk.END, "No bidders.")
        else:
            if self.last_bidder and self.last_bidder in self.bidders:
                data = self.bidders[self.last_bidder]
                display_username = data.get('original_username', self.last_bidder)
                self.bin_display.insert(tk.END, f"Bin {data['bin']}: {display_username}\n")
            remaining_bidders = [(username, data) for username, data in self.bidders.items() if username != self.last_bidder]
            sorted_bidders = sorted(remaining_bidders, key=lambda x: x[1]['bin'], reverse=True)
            for username, data in sorted_bidders:
                display_username = data.get('original_username', username)
                self.bin_display.insert(tk.END, f"Bin {data['bin']}: {display_username}\n")
        self.bin_display.config(state="disabled")
        self.bin_display.tag_configure("latest", font=("Helvetica", 10, "bold"))
        self.bin_display.see("1.0")

    def add_bidder(self):
        original_username = self.username_entry.get().strip()
        username = original_username.lower()
        qty_str = self.qty_entry.get().strip()
        weight = self.weight_entry.get() or ""
        is_giveaway = self.giveaway_var.get()
        if not username:
            messagebox.showerror("Error", "Username required!")
            logging.warning("Add bidder failed: Username required")
            return
        try:
            qty = int(qty_str) if qty_str else 1
            if qty <= 0:
                raise ValueError
        except ValueError:
            messagebox.showerror("Error", "Invalid quantity!")
            logging.warning("Add bidder failed: Invalid quantity")
            return
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")
        if username in self.bidders:
            txn = {'bin': self.bidders[username]['bin'], 'qty': qty, 'weight': weight, 'giveaway': is_giveaway,
                   'giveaway_num': self.next_giveaway_num if is_giveaway else 0, 'timestamp': timestamp}
            self.bidders[username]['transactions'].append(txn)
            self.bidders[username]['total_items'] += qty
            if is_giveaway:
                self.next_giveaway_num += 1
                self.giveaway_count += 1
        else:
            if self.next_bin > self.max_bins:
                messagebox.showerror("Error", f"Bin limit reached ({self.max_bins} bins).")
                logging.warning(f"Add bidder failed: Bin limit reached ({self.max_bins})")
                return
            txn = {'bin': self.next_bin, 'qty': qty, 'weight': weight, 'giveaway': is_giveaway,
                   'giveaway_num': self.next_giveaway_num if is_giveaway else 0, 'timestamp': timestamp}
            self.bidders[username] = {
                'bin': self.next_bin,
                'transactions': [txn],
                'total_items': qty,
                'original_username': original_username
            }
            self.next_bin += 1
            if is_giveaway:
                self.next_giveaway_num += 1
                self.giveaway_count += 1
        self.last_bidder = username
        self.current_bidder_label.config(text=f"Username: {original_username} | Bin: {txn['bin']}")
        self.latest_bin_assignment = f"{original_username} | Bin: {txn['bin']}"
        self.socketio.emit('update', {'data': self.latest_bin_assignment})
        self.username_entry.delete(0, tk.END)
        self.qty_entry.delete(0, tk.END)
        self.qty_entry.insert(0, "1")
        self.weight_entry.set("")
        self.giveaway_var.set(False)
        self.update_treeview()
        self.update_bin_display()
        self.update_top_buyers()
        self.update_footer()
        logging.info(f"Added bidder: {original_username} | Bin: {txn['bin']}")

    def show_avg_sell_rate(self):
        if not self.bidders:
            messagebox.showinfo("Info", "No transactions to analyze.")
            logging.info("Avg sell rate: No transactions")
            return
        timestamps = []
        for user, data in self.bidders.items():
            for txn in data['transactions']:
                try:
                    ts = datetime.datetime.strptime(txn['timestamp'], "%Y-%m-%d %I:%M:%S %p")
                    timestamps.append(ts)
                except ValueError:
                    continue
        if len(timestamps) < 2:
            messagebox.showinfo("Info", "Need at least two transactions.")
            logging.info("Avg sell rate: Insufficient transactions")
            return
        timestamps.sort()
        time_diffs = [(timestamps[i + 1] - timestamps[i]).total_seconds() for i in range(len(timestamps) - 1)]
        avg_seconds = sum(time_diffs) / len(time_diffs)
        minutes, seconds = divmod(int(avg_seconds), 60)
        time_str = f"{minutes} min {seconds} sec" if minutes > 0 else f"{seconds} sec"
        messagebox.showinfo("Average Sell Rate", f"Average time per sale: {time_str}")
        logging.info(f"Avg sell rate calculated: {time_str}")

    def import_labels(self):
        file_path = filedialog.askopenfilename(filetypes=[("PDF files", "*.pdf")])
        if not file_path:
            return
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Importing Labels")
        progress_window.geometry("300x100")
        progress_window.configure(bg="#E6F0FA")
        progress_window.transient(self.root)
        progress_window.grab_set()
        tk.Label(progress_window, text="Processing PDF...", bg="#E6F0FA", font=("Helvetica", 10)).pack(pady=5)
        progress_bar = ttk.Progressbar(progress_window, orient="horizontal", length=250, mode="determinate")
        progress_bar.pack(pady=5)
        try:
            self.label_data = []
            with pdfplumber.open(file_path) as pdf:
                total_pages = len(pdf.pages)
                progress_bar["maximum"] = total_pages
                for page_num, page in enumerate(pdf.pages):
                    text = page.extract_text()
                    if not text:
                        try:
                            text = pytesseract.image_to_string(page.to_image().original)
                        except Exception as e:
                            logging.warning(f"OCR failed on page {page_num}: {str(e)}")
                    matches = [m.strip().lower() for m in re.findall(r'\((.*?)\)', text or "")]
                    for username in self.bidders.keys():
                        if username in matches:
                            self.label_data.append({
                                "bin_number": self.bidders[username]["bin"],
                                "username": username,
                                "pdf_page": page_num,
                                "pdf_path": file_path
                            })
                    progress_bar["value"] = page_num + 1
                    self.root.update()
            progress_window.destroy()
            if self.label_data:
                missing = set(self.bidders.keys()) - {l["username"] for l in self.label_data}
                if missing:
                    missing_display = [self.bidders[username].get('original_username', username) for username in missing]
                    messagebox.showinfo("Notice", f"Imported {len(self.label_data)} labels. Some bidders not found: {', '.join(missing_display)}")
                    logging.info(f"Imported {len(self.label_data)} labels, missing: {missing_display}")
                else:
                    messagebox.showinfo("Success", f"Imported {len(self.label_data)} labels.")
                    logging.info(f"Imported {len(self.label_data)} labels")
            else:
                messagebox.showwarning("Warning", "No matching usernames found in PDF.")
                logging.warning("No matching usernames found in PDF")
            self.update_footer()
        except Exception as e:
            progress_window.destroy()
            logging.error(f"Label import failed: {str(e)}")
            messagebox.showerror("Error", f"Import failed: {str(e)}")

    def clear_data(self):
        if messagebox.askyesno("Confirm", "Start new show?"):
            self.save_auction_history()
            self.bidders.clear()
            self.label_data.clear()
            self.last_bidder = None
            self.next_bin = 1
            self.next_giveaway_num = 1
            self.giveaway_count = 0
            self.tree.delete(*self.tree.get_children())
            self.search_result.config(text="")
            self.current_bidder_label.config(text="")
            self.latest_bin_assignment = "Waiting for bidder..."
            self.socketio.emit('update', {'data': self.latest_bin_assignment})
            self.show_id = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            self.bidder_csv_path = os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", f"bidder_history_{self.show_id}.csv")
            os.makedirs(os.path.dirname(self.bidder_csv_path), exist_ok=True)
            self.update_bin_display()
            self.update_top_buyers()
            self.update_stats()
            self.announcement_text.config(state="normal")
            self.announcement_text.delete("1.0", tk.END)
            self.announcement_text.config(state="disabled")
            messagebox.showinfo("Info", f"New show: {self.show_id}")
            self.update_footer()
            logging.info(f"Started new show: {self.show_id}")

    def search_bidders(self):
        q = self.search_entry.get().strip().lower()
        if not q:
            self.search_result.config(text="Enter query!")
            logging.warning("Search bidders: Empty query")
            return
        if q in self.bidders:
            data = self.bidders[q]
            display_username = data.get('original_username', q)
            self.search_result.config(text=f"Username: {display_username} | Bin: {data['bin']} | Items: {data['total_items']}")
            logging.info(f"Search bidders: Found {display_username}")
            return
        res = []
        for username, data in self.bidders.items():
            display_username = data.get('original_username', username)
            for t in data['transactions']:
                if q in username or q in str(t['qty']) or q in t['weight'].lower():
                    res.append(f"{display_username} | Bin {data['bin']} | {t['qty']}x | {t['weight']} | # {t['giveaway_num']} | {t['timestamp']}")
        self.search_result.config(text='\n'.join(res) if res else 'No matches!')
        logging.info(f"Search bidders: {'Found matches' if res else 'No matches'}")

    def update_treeview(self):
        self.tree.delete(*self.tree.get_children())
        for username, data in self.bidders.items():
            if not data['transactions']:
                continue
            last = data['transactions'][-1]
            display_username = data.get('original_username', username)
            parent = self.tree.insert('', 'end', text='+', open=False, values=(
                display_username, data['bin'], last['qty'], last['weight'], 'Yes' if last['giveaway'] else 'No', last['giveaway_num'], last['timestamp']))
            for t in data['transactions'][:-1]:
                self.tree.insert(parent, 'end', values=(
                    '', data['bin'], t['qty'], t['weight'], 'Yes' if t['giveaway'] else 'No', t['giveaway_num'], t['timestamp']))
        def on_click(e):
            iid = self.tree.identify_row(e.y)
            if iid:
                self.tree.item(iid, open=not self.tree.item(iid, 'open'))
        self.tree.bind('<ButtonRelease-1>', on_click)
        logging.info("Updated treeview")

    def print_bidders(self):
        if not self.bidders:
            messagebox.showinfo("Info", "No bidders to export.")
            logging.info("Print bidders: No bidders")
            return
        csv_columns = ["username", "bin", "qty", "weight", "giveaway", "giveaway_num", "timestamp"]
        try:
            os.makedirs(os.path.dirname(self.bidder_csv_path), exist_ok=True)
            with open(self.bidder_csv_path, mode="a", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=csv_columns)
                if os.path.getsize(self.bidder_csv_path) == 0:
                    writer.writeheader()
                for username, data in self.bidders.items():
                    display_username = data.get('original_username', username)
                    for t in data["transactions"]:
                        writer.writerow({
                            "username": display_username,
                            "bin": data["bin"],
                            "qty": t["qty"],
                            "weight": t["weight"],
                            "giveaway": "Yes" if t["giveaway"] else "No",
                            "giveaway_num": t["giveaway_num"] if t["giveaway"] else "",
                            "timestamp": t["timestamp"]
                        })
            messagebox.showinfo("Success", f"Data appended to {self.bidder_csv_path}")
            logging.info(f"Bidders exported to {self.bidder_csv_path}")
        except Exception as e:
            logging.error(f"Bidders export failed: {str(e)}")
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def save_auction_history(self):
        if not self.bidders:
            return
        csv_path = os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", f"auction_history_{self.show_id}.csv")
        try:
            os.makedirs(os.path.dirname(csv_path), exist_ok=True)
            with open(csv_path, mode="w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=["show_id", "start_time", "end_time", "total_bidders", "total_transactions"])
                writer.writeheader()
                writer.writerow({
                    "show_id": self.show_id,
                    "start_time": self.show_start_time,
                    "end_time": datetime.datetime.now().strftime("%Y-%m-%d %I:%M:%S %p"),
                    "total_bidders": len(self.bidders),
                    "total_transactions": sum(len(data["transactions"]) for data in self.bidders.values())
                })
            logging.info(f"Auction history saved to {csv_path}")
        except Exception as e:
            logging.error(f"Auction history save failed: {str(e)}")
            messagebox.showerror("Error", f"Save failed: {str(e)}")

    def print_labels(self):
        if not self.label_data:
            messagebox.showwarning("Warning", "No labels imported.")
            logging.warning("Print labels: No labels")
            return
        try:
            bin_range = self.bin_range_entry.get().strip() or f"1-{self.max_bins}"
            start_bin, end_bin = map(int, bin_range.split("-"))
            if end_bin > self.max_bins or start_bin < 1:
                messagebox.showerror("Error", f"Bin range must be between 1 and {self.max_bins}.")
                logging.warning(f"Print labels: Invalid bin range {bin_range}")
                return
            labels = [l for l in sorted(self.label_data, key=lambda x: x["bin_number"]) if start_bin <= l["bin_number"] <= end_bin]
            if not labels:
                messagebox.showwarning("Warning", f"No labels found in bin range {start_bin}-{end_bin}.")
                logging.warning(f"Print labels: No labels in range {start_bin}-{end_bin}")
                return
            printed_count = 0
            for label in labels:
                doc = fitz.open(label["pdf_path"])
                page = doc[label["pdf_page"]]
                text_x = float(self.text_x_entry.get() or 50)
                text_y = float(self.text_y_entry.get() or 50)
                label_text = self.label_text_entry.get().format(bin_number=label["bin_number"])
                page.insert_text((text_x, text_y), label_text, fontsize=12, fontname="helv", color=(0, 0, 0))
                temp_doc = fitz.open()
                temp_doc.insert_pdf(doc, from_page=label["pdf_page"], to_page=label["pdf_page"])
                temp_pdf = os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", f"label_bin_{label['bin_number']}.pdf")
                os.makedirs(os.path.dirname(temp_pdf), exist_ok=True)
                temp_doc.save(temp_pdf)
                temp_doc.close()
                doc.close()
                if os.name == "nt":
                    os.startfile(temp_pdf, "print")
                else:
                    subprocess.run(["lp", temp_pdf], check=True)
                os.remove(temp_pdf)
                printed_count += 1
            messagebox.showinfo("Success", f"Printed {printed_count} labels for bins {start_bin}-{end_bin}.")
            logging.info(f"Printed {printed_count} labels for bins {start_bin}-{end_bin}")
        except ValueError:
            messagebox.showerror("Error", "Invalid bin range format. Use 'start-end'.")
            logging.error("Print labels: Invalid bin range format")
        except Exception as e:
            logging.error(f"Print labels failed: {str(e)}")
            messagebox.showerror("Error", f"Print failed: {str(e)}")

    def test_print_label(self):
        if not self.label_data:
            messagebox.showwarning("Warning", "No labels imported.")
            logging.warning("Test print: No labels")
            return
        try:
            label = sorted(self.label_data, key=lambda x: x["bin_number"])[0]
            doc = fitz.open(label["pdf_path"])
            page = doc[label["pdf_page"]]
            text_x = float(self.text_x_entry.get() or 50)
            text_y = float(self.text_y_entry.get() or 50)
            label_text = self.label_text_entry.get().format(bin_number=label["bin_number"])
            page.insert_text((text_x, text_y), label_text, fontsize=12, fontname="helv", color=(0, 0, 0))
            temp_doc = fitz.open()
            temp_doc.insert_pdf(doc, from_page=label["pdf_page"], to_page=label["pdf_page"])
            temp_pdf = os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", "test_label.pdf")
            os.makedirs(os.path.dirname(temp_pdf), exist_ok=True)
            temp_doc.save(temp_pdf)
            temp_doc.close()
            doc.close()
            if os.name == "nt":
                os.startfile(temp_pdf, "print")
            else:
                subprocess.run(["lp", temp_pdf], check=True)
            os.remove(temp_pdf)
            messagebox.showinfo("Success", f"Test label printed for bin {label['bin_number']}.")
            logging.info(f"Test label printed for bin {label['bin_number']}")
        except Exception as e:
            logging.error(f"Test print failed: {str(e)}")
            messagebox.showerror("Error", f"Test print failed: {str(e)}")

    def preview_labels(self):
        if not self.label_data:
            messagebox.showwarning("Warning", "No labels to preview.")
            logging.warning("Preview labels: No labels")
            return
        try:
            label = sorted(self.label_data, key=lambda x: x["bin_number"])[0]
            doc = fitz.open(label["pdf_path"])
            page = doc[label["pdf_page"]]
            text_x = float(self.text_x_entry.get() or 50)
            text_y = float(self.text_y_entry.get() or 50)
            label_text = self.label_text_entry.get().format(bin_number=label["bin_number"])
            page.insert_text((text_x, text_y), label_text, fontsize=12, fontname="helv", color=(0, 0, 0))
            pix = page.get_pixmap(matrix=fitz.Matrix(0.5, 0.5))
            img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
            photo = ImageTk.PhotoImage(img)
            win = tk.Toplevel(self.root)
            win.title("Label Preview")
            win.geometry("300x400")
            canvas = tk.Canvas(win, width=300, height=400, bg="white")
            canvas.pack()
            canvas.create_image(0, 0, image=photo, anchor="nw")
            canvas.image = photo
            doc.close()
            logging.info(f"Previewed label for bin {label['bin_number']}")
        except Exception as e:
            logging.error(f"Label preview failed: {str(e)}")
            messagebox.showerror("Error", f"Preview failed: {str(e)}")

    def export_labels(self):
        if not self.label_data:
            messagebox.showwarning("Warning", "No labels to export.")
            logging.warning("Export labels: No labels")
            return
        try:
            csv_path = os.path.join(os.path.expanduser("~"), "Documents", "SwiftSale", f"labels_{self.show_id}.csv")
            os.makedirs(os.path.dirname(csv_path), exist_ok=True)
            with open(csv_path, mode="w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=["username", "bin_number", "pdf_page"])
                writer.writeheader()
                for label in sorted(self.label_data, key=lambda x: x["bin_number"]):
                    username = label["username"]
                    display_username = self.bidders.get(username, {}).get('original_username', username)
                    writer.writerow({
                        "username": display_username,
                        "bin_number": label["bin_number"],
                        "pdf_page": label["pdf_page"]
                    })
            messagebox.showinfo("Success", f"Labels exported to {csv_path}")
            logging.info(f"Labels exported to {csv_path}")
        except Exception as e:
            logging.error(f"Label export failed: {str(e)}")
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def show_printer_setup(self):
        messagebox.showinfo("Printer Setup Guide", """
        Printer Setup Instructions:
        1. Use Google Chrome for Whatnot label printing.
        2. Ensure pop-ups are enabled in Chrome settings.
        3. For thermal printers (4x6):
           - Set paper size to 4x6 inches.
           - Use portrait orientation.
        4. For standard printers (8.5x11):
           - Set paper size to Letter.
           - Enable 'Fit to Page' in print settings.
        5. If labels print sideways, adjust orientation.
        6. Perform a test print first.
        7. Ensure your default PDF viewer supports printing.
        """)
        logging.info("Displayed printer setup guide")

if __name__ == '__main__':
    root = tk.Tk()
    app = SCDWhatnotGUI(root)
    root.mainloop()